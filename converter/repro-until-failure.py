#!/usr/bin/env python3

"""
Repeatedly enqueue a large test map request and watch monitor log output until a
premature/failed converter execution is detected.

Designed to work with monitor output generated by:
  ./monitor-converter.sh --log-file /tmp/touch-mapper-monitor.log
"""

import argparse
import copy
import json
import os
import re
import sys
import time
import urllib.parse
import urllib.request
import uuid
from collections import deque


LINE_RE = re.compile(r"^(?P<ts>\S+)\s+\[(?P<src>[^\]]+)\]\s?(?P<msg>.*)$")
PROGRESS_STAGE_RE = re.compile(r"PROGRESS:process-request:(?P<stage>[^\s]+)")
STATUS_RE = re.compile(r"\bstatus=(?P<status>[^\s]+)")

DEFAULT_SQS_ENDPOINT = (
    "https://sqs.eu-west-1.amazonaws.com/730535225693/test-requests-touch-mapper"
)

# Close to your existing stress case; script overrides requestId on each attempt.
DEFAULT_REQUEST_TEMPLATE = {
    "addrShort": "Helsinki Central Railway Station",
    "addrLong": "Helsinki Central Railway Station",
    "printingTech": "3d",
    "offsetX": 0,
    "offsetY": 0,
    "size": 17,
    "hideLocationMarker": True,
    "lon": 24.9405947,
    "lat": 60.1715453,
    "effectiveArea": {
        "lonMin": 24.932938538321324,
        "lonMax": 24.948250861678673,
        "latMin": 60.16773073799442,
        "latMax": 60.17535986200558
    },
    "scale": 5000,
    "diameter": 850,
    "multipartMode": False,
    "multipartXpc": 0,
    "multipartYpc": 0,
    "advancedMode": True,
    "requestId": "placeholder/unused"
}


def parse_args():
    parser = argparse.ArgumentParser(
        description=(
            "Enqueue repeated Touch Mapper test requests and stop when a failure "
            "is detected from monitor log markers."
        )
    )
    parser.add_argument(
        "--log-path",
        default="/tmp/touch-mapper-monitor.log",
        help="Path to live monitor log file (default: /tmp/touch-mapper-monitor.log)"
    )
    parser.add_argument(
        "--sqs-endpoint",
        default=DEFAULT_SQS_ENDPOINT,
        help="Unsigned SQS SendMessage endpoint (default: test queue endpoint)"
    )
    parser.add_argument(
        "--request-template-json",
        help="Optional JSON file with request template body"
    )
    parser.add_argument(
        "--request-id-prefix",
        default="Repro",
        help="Prefix for generated requestId values (default: Repro)"
    )
    parser.add_argument(
        "--attempt-timeout-seconds",
        type=int,
        default=1200,
        help="Max seconds to wait for one attempt before marking as failed (default: 1200)"
    )
    parser.add_argument(
        "--max-attempts",
        type=int,
        default=0,
        help="Stop after this many attempts even with no failure (0 means unlimited)"
    )
    parser.add_argument(
        "--sleep-between-seconds",
        type=float,
        default=1.0,
        help="Delay between attempts (default: 1.0)"
    )
    parser.add_argument(
        "--line-buffer-size",
        type=int,
        default=220,
        help="How many recent monitor lines to keep for failure context (default: 220)"
    )
    return parser.parse_args()


def extract_request_id(progress_msg):
    marker = "requestId="
    marker_index = progress_msg.find(marker)
    if marker_index < 0:
        return None
    tail = progress_msg[marker_index + len(marker):]
    end = len(tail)
    for delimiter in (" detail=", " last_stage=", " signal="):
        idx = tail.find(delimiter)
        if idx >= 0:
            end = min(end, idx)
    value = tail[:end].strip()
    return value if value else None


def build_request_body(template, request_id_prefix):
    request_body = copy.deepcopy(template)
    request_token = uuid.uuid4().hex[:12]
    request_body["requestId"] = "{prefix}{token}/Helsinki".format(
        prefix=request_id_prefix,
        token=request_token
    )
    return request_body


def send_request_via_unsigned_sqs_get(sqs_endpoint, request_body):
    params = {
        "Action": "SendMessage",
        "MessageBody": json.dumps(request_body, separators=(",", ":")),
        "Version": "2012-11-05"
    }
    url = sqs_endpoint + "?" + urllib.parse.urlencode(params)
    req = urllib.request.Request(url=url, method="GET")
    with urllib.request.urlopen(req, timeout=35) as response:
        response_text = response.read().decode("utf-8", errors="replace")
        status_code = response.getcode()
    if status_code != 200:
        raise RuntimeError("SQS SendMessage failed with HTTP {}".format(status_code))
    if "SendMessageResponse" not in response_text and "SendMessageResult" not in response_text:
        raise RuntimeError("SQS response did not look like SendMessageResponse")
    return response_text


def match_progress_for_request(message, request_id):
    stage_match = PROGRESS_STAGE_RE.search(message)
    if not stage_match:
        return None
    message_request_id = extract_request_id(message)
    if message_request_id != request_id:
        return None
    status_match = STATUS_RE.search(message)
    status = status_match.group("status") if status_match else None
    return (stage_match.group("stage"), status)


def wait_for_attempt_outcome(log_path, request_id, start_offset, timeout_seconds, line_buffer_size):
    recent_lines = deque(maxlen=line_buffer_size)
    started = False
    last_stage = None
    last_status = None
    deadline = time.time() + timeout_seconds

    # Wait for log file to appear if it does not yet exist.
    while not os.path.exists(log_path):
        if time.time() >= deadline:
            return {
                "ok": False,
                "reason": "monitor log file did not appear in time",
                "request_started": False,
                "last_stage": None,
                "last_status": None,
                "recent_lines": list(recent_lines),
            }
        time.sleep(0.3)

    with open(log_path, "r", encoding="utf-8", errors="replace") as handle:
        file_size = os.path.getsize(log_path)
        if start_offset <= file_size:
            handle.seek(start_offset)
        else:
            handle.seek(0)

        while time.time() < deadline:
            line = handle.readline()
            if line == "":
                # Handle truncation / replacement in streamed logs.
                try:
                    current_size = os.path.getsize(log_path)
                    current_pos = handle.tell()
                    if current_pos > current_size:
                        handle.seek(0)
                except OSError:
                    pass
                time.sleep(0.25)
                continue

            clean_line = line.rstrip("\n")
            recent_lines.append(clean_line)

            parsed = LINE_RE.match(clean_line)
            if not parsed:
                continue

            source = parsed.group("src")
            message = parsed.group("msg")

            progress = match_progress_for_request(message, request_id)
            if progress is not None:
                stage, status = progress
                started = True
                last_stage = stage
                last_status = status

                if stage in ("failed", "signal-received"):
                    return {
                        "ok": False,
                        "reason": "stage {}".format(stage),
                        "request_started": started,
                        "last_stage": last_stage,
                        "last_status": last_status,
                        "recent_lines": list(recent_lines),
                    }

                if stage == "exit":
                    success = (status == "success")
                    return {
                        "ok": success,
                        "reason": "exit status={}".format(status),
                        "request_started": started,
                        "last_stage": last_stage,
                        "last_status": last_status,
                        "recent_lines": list(recent_lines),
                    }

            # Poller-level hard exits (timeout/signal) are useful clues.
            if started and source == "poller.log":
                lower = message.lower()
                if "request processing exited with timeout" in lower:
                    return {
                        "ok": False,
                        "reason": "poller timeout",
                        "request_started": started,
                        "last_stage": last_stage,
                        "last_status": last_status,
                        "recent_lines": list(recent_lines),
                    }
                if "request processing exited with sigkill" in lower:
                    return {
                        "ok": False,
                        "reason": "poller sigkill",
                        "request_started": started,
                        "last_stage": last_stage,
                        "last_status": last_status,
                        "recent_lines": list(recent_lines),
                    }
                if "request processing exited with sigterm" in lower:
                    return {
                        "ok": False,
                        "reason": "poller sigterm",
                        "request_started": started,
                        "last_stage": last_stage,
                        "last_status": last_status,
                        "recent_lines": list(recent_lines),
                    }

            if started and source in ("request.log", "prev-request.log"):
                if "process-request failed:" in message:
                    return {
                        "ok": False,
                        "reason": "process-request failed line",
                        "request_started": started,
                        "last_stage": last_stage,
                        "last_status": last_status,
                        "recent_lines": list(recent_lines),
                    }

    timeout_reason = "timeout waiting for terminal stage"
    if not started:
        timeout_reason = "no progress lines seen for request"
    return {
        "ok": False,
        "reason": timeout_reason,
        "request_started": started,
        "last_stage": last_stage,
        "last_status": last_status,
        "recent_lines": list(recent_lines),
    }


def load_request_template(path):
    if not path:
        return copy.deepcopy(DEFAULT_REQUEST_TEMPLATE)
    with open(path, "r", encoding="utf-8") as handle:
        return json.load(handle)


def print_recent_lines(lines):
    print("---- recent monitor lines ----")
    for line in lines:
        print(line)
    print("---- end recent monitor lines ----")


def main():
    args = parse_args()
    request_template = load_request_template(args.request_template_json)

    print("Watching log: {}".format(args.log_path))
    print("Queue endpoint: {}".format(args.sqs_endpoint))
    if args.max_attempts > 0:
        print("Will run at most {} attempts".format(args.max_attempts))
    else:
        print("Will run attempts until first failure")

    attempt_index = 1
    while True:
        if args.max_attempts > 0 and attempt_index > args.max_attempts:
            print("Reached max attempts with no detected failure.")
            return 0

        request_body = build_request_body(request_template, args.request_id_prefix)
        request_id = request_body["requestId"]

        try:
            start_offset = os.path.getsize(args.log_path) if os.path.exists(args.log_path) else 0
        except OSError:
            start_offset = 0

        print("")
        print("Attempt {} requestId={}".format(attempt_index, request_id))
        send_request_via_unsigned_sqs_get(args.sqs_endpoint, request_body)
        print("queued request, waiting for outcome...")

        result = wait_for_attempt_outcome(
            log_path=args.log_path,
            request_id=request_id,
            start_offset=start_offset,
            timeout_seconds=args.attempt_timeout_seconds,
            line_buffer_size=args.line_buffer_size,
        )

        if result["ok"]:
            print(
                "SUCCESS requestId={} terminal={} status={}".format(
                    request_id,
                    result["last_stage"],
                    result["last_status"],
                )
            )
            attempt_index += 1
            time.sleep(args.sleep_between_seconds)
            continue

        print(
            "FAILURE DETECTED requestId={} reason={} last_stage={} last_status={}".format(
                request_id,
                result["reason"],
                result["last_stage"],
                result["last_status"],
            )
        )
        print_recent_lines(result["recent_lines"])
        return 1


if __name__ == "__main__":
    sys.exit(main())
